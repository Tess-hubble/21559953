<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>


<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="A deep dive into Colplay and Metallica" />




<meta name="author" content="Tessa Hubble" />


<meta name="description" content="A deep dive into Colplay and Metallica">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","bibliography":"Tex/ref.bib","date":"July 2023","csl":"Template/harvard-stellenbosch-university.csl","output":{"pagedown::html_paged":{"self_contained":true,"toc":true,"css":["Template/default-fonts-Texevier.css","Template/default-page-Texevier.css","Template/default-Texevier.css"],"csl":"Template/harvard-stellenbosch-university.csl","template":["Template/paged-Texevier.html"]}},"author":"Tessa Hubble","abstract":"<p>Visualising the progression of some of the most famous bands.</p>","title":"A deep dive into Colplay and Metallica"}
</script>

<title>A deep dive into Colplay and Metallica</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>



<style type="text/css">
h3.abstract{
text-align: center;
}
div.abstract{
margin: auto;
width: 90%;
}
</style>

<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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IC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsD4sIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsD8sIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEAsIyAuRrACJUawEENYUBtSWVggPFkjIC5GsAIlRrAQQ1hSG1BZWCA8WS6xLgEUKy2wQSywOCsjIC5GsAIlRrAQQ1hQG1JZWCA8WS6xLgEUKy2wQiywOSuKICA8sAQjQoo4IyAuRrACJUawEENYUBtSWVggPFkusS4BFCuwBEMusC4rLbBDLLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLEuARQrLbBELLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuw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) format('truetype');
}
body {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;}blockquote {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;}code {font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;}pre, code {font-size: .95em;}</style>
<style type="text/css">@page {size: 6in 9in; }@page :blank {}.shorttitle1 {string-set: h1-text content(text);}.shorttitle2 {string-set: h2-text content(text);}.running-h1-title {position: running(runningH1Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h1-title:before {content: string(h1-text);}@page chapter:left {@top-left {content: counter(page);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}.running-h2-title {position: running(runningH2Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h2-title:before {content: string(h2-text);}@page chapter:right {@top-right {content: counter(page);}@top-left {content: element(runningH2Title);white-space: nowrap !important;}}@page chapter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page);}}@page :first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: none !important;}background-image: var(--front-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.front-cover {break-after: recto;}.front-page {counter-reset: page 1;}@page frontmatter:left {@top-left {content: counter(page, lower-roman);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:left {@top-right {content: counter(page, lower-roman);}@top-left {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page, lower-roman);}}.back-cover {break-before: verso;}.pagedjs_page:nth-last-of-type(1) {background-image: var(--back-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.level1 {break-before: avoid;page: chapter;}.front-matter-container .level1 {page: frontmatter;}.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {break-before: avoid;break-after: avoid;}.footenotes {break-before: always;break-after: always;}.figure {break-inside: avoid;}.main .level1:first-child h1 {counter-reset: page 1;}caption {break-inside: avoid;break-after: avoid;}</style>
<style type="text/css">:root {--background: whitesmoke;--pagedjs-width: 6in;--pagedjs-height: 9in;--color-paper: white;--color-mbox: rgba(0, 0, 0, 0.2);--running-title-width: 2.5in;--screen-pages-spacing: 5mm;}html {line-height: 1.3;}.abstract {border-width: 0.5px 0;border-style: solid;margin-top: 0px;margin-bottom: 2px;font-size: 12px;}a[href^="http"]:not([class="uri"])::after {content: " (" attr(href) ")";font-size: 90%;hyphens: none;word-break: break-all;}.references a[href^=http]:not([class=uri])::after {content: none;}.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page) ")";}.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page, lower-roman) ")";}.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: unset;}h1 {font-weight: bold;font-size: 23px;}h2 {font-weight: bold;font-size: 20px;}p {font-size: 12px;}.sourceCode {font-size: 10px;}.toc ul, .lot ul, .lof ul {list-style: none;padding-left: 0;overflow-x: hidden;}.toc li li {padding-left: 1em;}.toc a, .lot a, .lof a {text-decoration: none;background: white;padding-right: .33em;font-size: 11px;}.toc a::after, .lot a::after, .lof a::after {content: target-counter(attr(href), page);float: right;background: white;}.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {content: target-counter(attr(href), page, lower-roman);}.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {float: left;width: 0;white-space: nowrap;content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";}.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {content: var(--chapter-name-before, "Chapter ");}.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {content: var(--chapter-name-after, "");}.subtitle span {font-size: .9em;}img {max-width: 100%;}pre {padding: 1em;white-space: pre-wrap;}pre[class] {background: #f9f9f9;}abbr {text-decoration: none;}@media screen {div.sourceCode {overflow: visible !important;}a.sourceLine::before {text-decoration: unset !important;}}pre.numberSource a.sourceLine {left: 0 !important;text-indent: -5em}pre.numberSource {margin-left: 0 !important;}table {margin: auto;border-top: 1px solid #666;border-bottom: 1px solid #666;}table thead th {border-bottom: 1px solid #ddd;}thead, tfoot, tr:nth-child(even) {background: #eee;}.kable_wrapper > tbody > tr > td {vertical-align: top;}.footnotes {font-size: 90%;}.footnotes hr::before {content: "Footnotes:";}.footnotes hr {border: none;}.footnote-break {width: 1in;}body {hyphens: auto;}code {hyphens: none;}@media screen {body {background-color: var(--background);margin: var(--screen-pages-spacing) auto 0 auto;}.pagedjs_pages {display: flex;max-width: calc(var(--pagedjs-width) * 2);flex: 0;flex-wrap: wrap;margin: 0 auto;}.pagedjs_page {background-color: var(--color-paper);box-shadow: 0 0 0 1px var(--color-mbox);flex-shrink: 0;flex-grow: 0;margin: auto auto var(--screen-pages-spacing) auto;}}@media screen and (min-width: 12.32in) {.pagedjs_page {margin: auto 0 var(--screen-pages-spacing) 0;}.pagedjs_first_page {margin-left: var(--pagedjs-width);}}@media screen and (max-width:1180px) {body {width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));}}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">A deep dive into Colplay and Metallica</h1>
<h5 class="author">Tessa Hubble</h5>
<h5 class="date">July 2023</h5>
</div>
<div class="abstract">
<h3 class="abstract">Abstract</h3>
<p>Visualising the progression of some of the most famous bands.</p>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
</ul>
</div>
</div>

<div class="main">
<div class="page-break-after"></div>
<div id="introduction" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>The two figures below breakdown Coldplay’s and Metallica’s albums by valence, energy and instrumentalness. In terms of Coldplay, we see that their album, X&amp;Y had remarkably low instrumentalness compared to their other albums. This shows that that this particular album had more vocals and fewer instrumental interludes. Coldplay covers the full distribution of energy. Valence tends to remain below 0.4. This conveys that their songs tend to be fairly sad or depressed.</p>
<p><img src="data:image/png;base64,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" width="672" style="display: block; margin: auto;" /></p>
<p>Figure 2 of Metallica’s albums tells a different story. Metallica songs tend to be higher than 0.5 in terms of energy and covers the full distribution of valence. Energy builds in instances when musicians sing louder and/or when the drums pick up tempo. Metallica tends towards high energy songs but has evenly distributed positive and negative sounds. There also appears to be varying levels of instrumentalness within Metallica’s repertoire.</p>
<p><img src="data:image/png;base64,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" width="672" style="display: block; margin: auto;" /></p>
<p>Figure 3 below compares Metallica and Coldplay along their songs’ levels of danceability and tempo.
Coldplay’s songs are more concentrated around a higher level of tempo while both bands hover around a danceability of 0.5.</p>
<p><img src="data:image/png;base64,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uP+9LH+m2erngf4J/CcBJVcvoL8O2p3ZYqZZBXTxdFMVzHpkmuai/f3qh2m/nommM6pxGAEBJVcvoLNl/erDqxzWnSzbsqZgNgNpa9IeraQGe6CUcRBQcnUD2t2eVlPKdKC5xTltg3nbBnTS/eFyuDsCz5uAkqsbzcWdzaWUxNXg/YC288xqZBXaTnPhmRNQcoUD2q4VzeqA9qeuMAICSq61gE4eGTQDZfsIKLnW7oH24/dvAXUPlHESUHL1VuGXa+1NSzcFtEltndLZ8vHPW591YiwElFzrz4E2XbxdFHFTQJtOeg6U0RJQct17E6l6u7194WhjQIvjm/LurAlp500kE1BGQkDJ9di78IsJ5aaAvjvofYfZu/CMjoCS6/7XmN6kDL49Xxt8YBGpmn0Wq68v1V9jOrp+qguHXALKMDqr8DBWAsowBJQtIKAMQ0DZAgLKMASULSCgDENA2QICyjAElC0goABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEECChAkoABBAgoQJKAAQQIKECSgAEF/AXKXUoZSRK27AAAAAElFTkSuQmCC" width="672" style="display: block; margin: auto;" /></p>
<p>Figure 4 below shows the average energy, valence and instrumentallness within the rock/alternative/indie genre. This is the genre within which both Metallica and Coldplay operate. Metallica is more in line with the genre’s high energy level while Coldplay is closer to the genre’s level of valence. Both Metallica and Coldplay appear to be above the genre’s average instrumentalness.</p>
<p><img src="data:image/png;base64,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" width="576" style="display: block; margin: auto;" /></p>
<p>Figures 5 and 6 show the popularity of each of the albums of Coldplay and Metallica. It becomes clear from these figures that a larger proportion of Coldplay’s album have higher popularity scores.</p>
<p><img src="data:image/png;base64,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" width="576" style="display: block; margin: auto;" /></p>
<p><img src="data:image/png;base64,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" width="576" style="display: block; margin: auto;" /></p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
